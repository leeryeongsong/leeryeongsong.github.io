---
title:  "20210729 TIL"
excerpt: " 백준 단계별로 풀어보기 7단계 중 예제 5~6단계 작성(1157번, 1152번)"
toc: true
toc_sticky: true
categories:
  - TIL
tags:
  - TIL
  - 백준
---

## 백준 단계별로 풀어보기 7단계 중 예제 5\~6단계 작성하기  
1157번, 1152번 문제를 풀고 다음 글에 해당 내용을 업데이트했다.    
[[7단계] 파이썬3으로 백준 단계별로 풀어보기- 문자열](https://leeryeongsong.github.io/baekjoon/baekjoon-step-by-step-python3-step7/)  
<br>
예제 6단계 문제는 파이썬의 메소드 split() 덕분에 풀이가 빨리 끝났는데,  
예제 5단계 문제를 다양한 방식으로 풀이하느라 시간이 오래 걸렸다.   
1. 아스키 코드를 활용한다.  
for문으로 입력받은 문자열의 각 요소에 대해,  
if문으로 알파벳 대문자일 때는 리스트\[인덱스(아스키코드-65)\]에 +1을 더하고,   
알파벳 소문자 일때는 리스트\[인덱스(아스키코드-97)]에 +1을 더하여 알파벳 입력 횟수를 기록한다.  
위 방법을 사용하면 A와 a 모두 같은 리스트\[인덱스0]에 입력 횟수가 기록된다.  
<br>
2. 1번에 supper() 메소드를 활용하여 모든 문자를 대문자로 바꾼 문자열을 반환했다.  
1번과 비교했을 때,  
if문으로 알파벳이 대문자인지 소문자인지 사례를 나누는 과정이 사라졌다.  
<br>
3. 2번에 알파벳 입력 횟수를 저장할 때 count() 메소드를 적용했다(시간 초과).   
for문으로 입력받은 문자열의 각 요소에 대해 리스트의 요소에 알파벳 입력 횟수를 1씩 더하는 것이 아니라, count()로 해당 알파벳 개수를 대입했다. (<- 시간 초과의 원인?)  
<br>
위와 같이 코드를 구성할 경우  
이미 count()로 특정 알파벳의 입력 횟수를 기록했는데,  
이후 등장한 특정 알파벳으로 인해 다시 count() 메소드를 수행하는...일이 벌어진다.  
<br>
예시를 보이면  
aaaAAAbbbcsdfg 입력하면  
2번에서 추가한 upper() 메소드로 인해  
AAAAAABBBCSDFG로 저장되고,  
for문으로 입력받은 문자열의 각 요소에 대해 반복문을 진행하기 때문에,  
첫 번째 A에 대해, 리스트\[0]에 문자열 중 A 개수를 저장하고  
두 번째 A에 대해, 리스트\[0]에 문자열 중 A 개수를 저장하고  
세 번째 A에 대해, 리스트\[0]에 문자열 중 A 개수를 저장하고  
네 번째 A에 대해, 리스트\[0]에 문자열 중 A 개수를 저장하고  
...
이렇게 중복되는 과정을 거친다.  
<br>
어떻게 중복을 피할 수 있을까? 고민하다가 set 자료형이 생각났다.  
<br>
4. 3번에 set 자료형 적용하기 (런타임 에러(TypeError))  
중복을 피하기 위해 set 자료형을 적용했다.  
set 자료형으로 중복을 없애고,  
for문으로 set 자료형의 원소에 대해 반복문을 진행하여,  
해당 원소가 처음에 입력받은 문자열에 존재하는 개수를, 새로운 리스트에 추가하면 된다.  
그런데! 
마지막에 가장 입력 빈도가 높은 문자를 출력하기 위해   
set 자료형에 인덱스를 붙여서 출력했다가 오류가 나왔다.  
set 자료형은 순서가 없으므로 인덱스로 접근할 수 없다.  
<br>
5. 4번에, set 자료형을 list 자료형으로 변환하기.  
set 자료형을 list로 바꾸면 해결되는 문제였다.  
<br>
6. 5번에, 알파벳의 입력 빈도를 저장할 때 dictionary 자료형을 쓰고 싶다.  
dictionary 자료형으로 {'입력된 알파벳':(문자열 중 해당 알파벳 개수)} 형태로 저장하고 싶어졌다.  
<br>
최대 value를 가진 key값을 구하는 것은 생각보다 복잡하고, 방법이 다양했다.  
매우 다양한 방법을 설명한 링크 [[python] 사전에서 최대 값을 가진 키를 얻습니까?](http://daplus.net/python-%EC%82%AC%EC%A0%84%EC%97%90%EC%84%9C-%EC%B5%9C%EB%8C%80-%EA%B0%92%EC%9D%84-%EA%B0%80%EC%A7%84-%ED%82%A4%EB%A5%BC-%EC%96%BB%EC%8A%B5%EB%8B%88%EA%B9%8C/)  
<br>
value 중 최댓값을 구하고,  
리스트 컴프리헨션을 방법으로  
items() 메소드로 key, value 쌍을 가져오고, 최댓값 value와 같은 value를 가진 key 값을 리스트에 저장하는 방법이 있다.  
리스트 컴프리헨션으로 최대 value에 대한 key 찾는 법 알려준 링크 [[Python] dictionary max value에 대한 key 찾기](https://bio-info.tistory.com/40)  
<br>
이 리스트 길이가 1과 같으면(if) 리스트\[0] 출력,  
그렇지 않다면(else) ?(물음표) 출력  
<br>
다른 방법들도 있었지만 그건 value가 최대인 key가 1개로 유일할 때 유용했고,  
이 문제에서는 value가 최대인 key가 여러 개 등장하므로 위 방법이 사용하기에 적절했다.  
<br>
리스트 컴프리헨션에 대한 내용  
[22.5 리스트 표현식 사용하기](https://dojang.io/mod/page/view.php?id=2285)  
[2.6 리스트 컴프리헨션](https://wikidocs.net/84393)  
[1) 리스트 컴프리헨션](https://wikidocs.net/22805)  
<br>
<br>
GitHub에 올린 소스 코드 위치는 아래에 있다.  
[level5-1157-단어공부.py](https://github.com/leeryeongsong/baekjoon-step-by-step-python3/blob/main/step7/level5-1157-%EB%8B%A8%EC%96%B4%EA%B3%B5%EB%B6%80.py)  
[level6-1152-단어의개수.py](https://github.com/leeryeongsong/baekjoon-step-by-step-python3/blob/main/step7/level6-1152-%EB%8B%A8%EC%96%B4%EC%9D%98%EA%B0%9C%EC%88%98.py)
<br>
<br>
